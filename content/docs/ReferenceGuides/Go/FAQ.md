+++
title = "FAQ"
date = 2024-11-17T12:07:24+08:00
weight = 10
type = "docs"
description = ""
isCJKLanguage = true
draft = false
+++

> 原文：[https://protobuf.dev/reference/go/faq/](https://protobuf.dev/reference/go/faq/)
>
> 收录该文档的时间：`2024-11-17T12:07:24+08:00`

# Go FAQ - Go 常见问题解答

A list of frequently asked questions about implementing protocol buffers in Go, with answer for each.

​	有关在 Go 中实现 Protocol Buffers 的常见问题列表及其解答。

## 版本 Versions

### `github.com/golang/protobuf` 和 `google.golang.org/protobuf` 有什么区别？ What’s the difference between `github.com/golang/protobuf` and `google.golang.org/protobuf`?

The [`github.com/golang/protobuf`](https://pkg.go.dev/github.com/golang/protobuf?tab=overview) module is the original Go protocol buffer API.

​	[`github.com/golang/protobuf`](https://pkg.go.dev/github.com/golang/protobuf?tab=overview) 模块是最早的 Go Protocol Buffers API。

The [`google.golang.org/protobuf`](https://pkg.go.dev/google.golang.org/protobuf?tab=overview) module is an updated version of this API designed for simplicity, ease of use, and safety. The flagship features of the updated API are support for reflection and a separation of the user-facing API from the underlying implementation.

​	[`google.golang.org/protobuf`](https://pkg.go.dev/google.golang.org/protobuf?tab=overview) 模块是该 API 的更新版本，设计更简洁、易用且安全。更新后的 API 的主要特性包括对反射的支持以及用户 API 和底层实现的分离。

We recommend that you use `google.golang.org/protobuf` in new code.

​	我们建议在新代码中使用 `google.golang.org/protobuf`。

Version `v1.4.0` and higher of `github.com/golang/protobuf` wrap the new implementation and permit programs to adopt the new API incrementally. For example, the well-known types defined in `github.com/golang/protobuf/ptypes` are simply aliases of those defined in the newer module. Thus, [`google.golang.org/protobuf/types/known/emptypb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/emptypb) and [`github.com/golang/protobuf/ptypes/empty`](https://pkg.go.dev/github.com/golang/protobuf/ptypes/empty) may be used interchangeably.

​	从 `github.com/golang/protobuf` 的 `v1.4.0` 版本开始，该模块封装了新实现，并允许程序逐步采用新 API。例如，定义于 `github.com/golang/protobuf/ptypes` 的众所周知类型只是新模块中定义类型的别名。因此，[`google.golang.org/protobuf/types/known/emptypb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/emptypb) 和 [`github.com/golang/protobuf/ptypes/empty`](https://pkg.go.dev/github.com/golang/protobuf/ptypes/empty) 可以互换使用。

### 什么是 `proto1`、`proto2` 和 `proto3`？ What are `proto1`, `proto2`, and `proto3`?

These are revisions of the protocol buffer *language*. It is different from the Go *implementation* of protobufs.

​	这些是 Protocol Buffers **语言**的不同版本，与 Go 中 Protobuf 的**实现**不同。

- `proto3` is the current version of the language. This is the most commonly used version of the language. We encourage new code to use proto3.
  - **`proto3`** 是当前的语言版本，也是最常用的版本。我们鼓励在新代码中使用 proto3。

- `proto2` is an older version of the language. Despite being superseded by proto3, proto2 is still fully supported.

  - **`proto2`** 是语言的较早版本。尽管已被 proto3 取代，但 proto2 仍然完全受支持。

- `proto1` is an obsolete version of the language. It was never released as open source.

  - **`proto1`** 是语言的过时版本，从未以开源形式发布。

  

### 存在多个 `Message` 类型，我应该使用哪一个？ There are several different `Message` types. Which should I use?

- [`"google.golang.org/protobuf/proto".Message`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Message) is an interface type implemented by all messages generated by the current version of the protocol buffer compiler. Functions that operate on arbitrary messages, such as [`proto.Marshal`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal) or [`proto.Clone`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Clone), accept or return this type.

  - [`"google.golang.org/protobuf/proto".Message`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Message) 是当前 Protocol Buffers 编译器生成的所有消息实现的接口类型。操作任意消息的函数（例如 [`proto.Marshal`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal) 或 [`proto.Clone`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Clone)）接受或返回此类型。

- [`"google.golang.org/protobuf/reflect/protoreflect".Message`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message) is an interface type describing a reflection view of a message.

  - [`"google.golang.org/protobuf/reflect/protoreflect".Message`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message) 是描述消息反射视图的接口类型。


  Call the `ProtoReflect` method on a `proto.Message` to get a `protoreflect.Message`.

  ​	调用 `proto.Message` 的 `ProtoReflect` 方法以获取 `protoreflect.Message`。

- [`"google.golang.org/protobuf/reflect/protoreflect".ProtoMessage`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#ProtoMessage) is an alias of `"google.golang.org/protobuf/proto".Message`. The two types are interchangeable.

  - [`"google.golang.org/protobuf/reflect/protoreflect".ProtoMessage`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#ProtoMessage) 是 `"google.golang.org/protobuf/proto".Message` 的别名。这两个类型可以互换。

- [`"github.com/golang/protobuf/proto".Message`](https://pkg.go.dev/github.com/golang/protobuf/proto?tab=doc#Message) is an interface type defined by the legacy Go protocol buffer API. All generated message types implement this interface, but the interface does not describe the behavior expected from these messages. New code should avoid using this type.

  - [`"github.com/golang/protobuf/proto".Message`](https://pkg.go.dev/github.com/golang/protobuf/proto?tab=doc#Message) 是旧版 Go Protocol Buffers API 定义的接口类型。所有生成的消息类型都实现了此接口，但该接口未描述这些消息预期的行为。新代码应避免使用此类型。


## 常见问题 Common problems

### “`go install`”: `working directory is not part of a module`

On Go 1.15 and below, you have set the environment variable `GO111MODULE=on` and are running the `go install` command outside of a module directory. Set `GO111MODULE=auto`, or unset the environment variable.

​	**Go 1.15 及以下版本：** 您设置了环境变量 `GO111MODULE=on`，并在模块目录之外运行了 `go install` 命令。请将 `GO111MODULE` 设置为 `auto`，或者取消设置该环境变量。

On Go 1.16 and above, `go install` can be invoked outside of a module by specifying an explicit version: `go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`

​	**Go 1.16 及以上版本：** 可以通过指定显式版本在模块目录之外调用 `go install`：`go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`

### `constant -1 overflows protoimpl.EnforceVersion`

You are using a generated `.pb.go` file which requires a newer version of the `"google.golang.org/protobuf"` module.

​	您使用的生成 `.pb.go` 文件需要更新版本的 `"google.golang.org/protobuf"` 模块。

Update to a newer version with:

​	通过以下命令更新版本：

```shell
go get -u google.golang.org/protobuf/proto
```

### `undefined: "github.com/golang/protobuf/proto".ProtoPackageIsVersion4`

You are using a generated `.pb.go` file which requires a newer version of the `"github.com/golang/protobuf"` module.

​	您使用的生成 `.pb.go` 文件需要更新版本的 `"github.com/golang/protobuf"` 模块。

Update to a newer version with:

​	通过以下命令更新版本：

```shell
go get -u github.com/golang/protobuf/proto
```

### 什么是 Protocol Buffers 命名空间冲突？ What is a protocol buffer namespace conflict?

All protocol buffers declarations linked into a Go binary are inserted into a global registry.

​	所有链接到 Go 二进制文件中的 Protocol Buffers 声明都会插入全局注册表中。

Every protobuf declaration (for example, enums, enum values, or messages) has an absolute name, which is the concatenation of the [package name](https://protobuf.dev/programming-guides/proto2#packages) with the relative name of the declaration in the `.proto` source file (for example, `my.proto.package.MyMessage.NestedMessage`). The protobuf language assumes that all declarations are universally unique.

​	每个 Protobuf 声明（例如枚举、枚举值或消息）都有一个绝对名称，它是 [包名](https://protobuf.dev/programming-guides/proto2#packages) 和 `.proto` 源文件中声明的相对名称的连接（例如 `my.proto.package.MyMessage.NestedMessage`）。Protobuf 语言假定所有声明都是全局唯一的。

If two protobuf declarations linked into a Go binary have the same name, then this leads to a namespace conflict, and it is impossible for the registry to properly resolve that declaration by name. Depending on which version of Go protobufs is being used, this will either panic at init-time or silently drop the conflict and lead to a potential bug later during runtime.

​	如果两个 Protobuf 声明在 Go 二进制文件中具有相同的名称，则会导致命名空间冲突，注册表无法正确解析该名称。根据使用的 Go Protobuf 版本，这种情况可能会在初始化时引发恐慌或静默丢弃冲突，从而在运行时导致潜在错误。

### 如何解决 Protocol Buffers 命名空间冲突？ How do I fix a protocol buffer namespace conflict?

The way to best fix a namespace conflict depends on the reason why a conflict is occurring.

​	解决命名空间冲突的方法取决于冲突发生的原因。

Common ways that namespace conflicts occur:

​	以下是常见的冲突原因及解决方法：

- **Vendored .proto files.** When a single `.proto` file is generated into two or more Go packages and linked into the same Go binary, it conflicts on every protobuf declaration in the generated Go packages. This typically occurs when a `.proto` file is vendored and a Go package is generated from it, or the generated Go package itself is vendored. Users should avoid vendoring and instead depend on a centralized Go package for that `.proto` file.
  - **被嵌套的 .proto 文件。** 当单个 `.proto` 文件生成到两个或多个 Go 包中并链接到同一个 Go 二进制文件时，生成的 Go 包中的每个 Protobuf 声明都会冲突。这种情况通常发生在 `.proto` 文件被嵌套时，或者生成的 Go 包本身被嵌套时。用户应避免嵌套，改为依赖该 `.proto` 文件的集中式 Go 包。
  - If a `.proto` file is owned by an external party and is lacking a `go_package` option, then you should coordinate with the owner of that `.proto` file to specify a centralized Go package that a plurality of users can all depend on.
    - 如果 `.proto` 文件由外部方管理且缺少 `go_package` 选项，您应与 `.proto` 文件的所有者协调，指定一个集中的 Go 包，供多个用户依赖。
  
- **Missing or generic proto package names.** If a `.proto` file does not specify a package name or uses an overly generic package name (for example, “my_service”), then there is a high probability that declarations within that file will conflict with other declarations elsewhere in the universe. We recommend that every `.proto` file have a package name that is deliberately chosen to be universally unique (for example, prefixed with the name of a company).
  - **缺少或通用的 proto 包名。** 如果 `.proto` 文件未指定包名或使用过于通用的包名（例如 `"my_service"`），则该文件中的声明很可能与其他地方的声明冲突。建议为每个 `.proto` 文件选择一个全局唯一的包名（例如以公司名称为前缀）。
  - **Warning:** Retroactively changing the package name on a `.proto` file is not backwards compatible for types used as extension fields, stored in `google.protobuf.Any`, or for gRPC Service definitions. **警告：** 事后更改 `.proto` 文件的包名对以下类型的兼容性不友好：用作扩展字段的类型；存储在 `google.protobuf.Any` 中的类型；gRPC 服务定义。


Starting with v1.26.0 of the `google.golang.org/protobuf` module, a hard error will be reported when a Go program starts up that has multiple conflicting protobuf names linked into it. While it is preferable that the source of the conflict be fixed, the fatal error can be immediately worked around in one of two ways:

​	从 `google.golang.org/protobuf` 模块的 `v1.26.0` 版本开始，当 Go 程序启动时，如果链接了多个冲突的 Protobuf 名称，将报告一个严重错误。尽管最好解决冲突的根本原因，但可以通过以下两种方式立即解决致命错误：

1. **At compile time.** The default behavior for handling conflicts can be specified at compile time with a linker-initialized variable: **在编译时解决。** 可以通过链接器初始化变量在编译时指定处理冲突的默认行为： `go build -ldflags "-X google.golang.org/protobuf/reflect/protoregistry.conflictPolicy=warn"`
2. **At program execution.** The behavior for handling conflicts when executing a particular Go binary can be set with an environment variable: **在程序执行时解决。** 在执行特定 Go 二进制文件时，可以通过环境变量设置处理冲突的行为： `GOLANG_PROTOBUF_REGISTRATION_CONFLICT=warn ./main`

### 为什么 `reflect.DeepEqual` 在 Protobuf 消息中行为异常？ Why does `reflect.DeepEqual` behave unexpectedly with protobuf messages?

Generated protocol buffer message types include internal state which can vary even between equivalent messages.

​	生成的 Protobuf 消息类型包含内部状态，即使在等价消息之间也可能不同。

In addition, the `reflect.DeepEqual` function is not aware of the semantics of protocol buffer messages, and can report differences where none exist. For example, a map field containing a `nil` map and one containing a zero-length, non-`nil` map are semantically equivalent, but will be reported as unequal by `reflect.DeepEqual`.

​	此外，`reflect.DeepEqual` 函数不了解 Protobuf 消息的语义，可能报告不存在的差异。例如，包含 `nil` 映射的 map 字段和包含零长度非 `nil` 映射的 map 字段在语义上是等价的，但 `reflect.DeepEqual` 会将它们视为不相等。

Use the [`proto.Equal`](https://pkg.go.dev/google.golang.org/protobuf/proto#Equal) function to compare message values.

​	**解决方法：** 使用 [`proto.Equal`](https://pkg.go.dev/google.golang.org/protobuf/proto#Equal) 函数比较消息值。

In tests, you can also use the [`"github.com/google/go-cmp/cmp"`](https://pkg.go.dev/github.com/google/go-cmp/cmp?tab=doc) package with the [`protocmp.Transform()`](https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp#Transform) option. The `cmp` package can compare arbitrary data structures, and [`cmp.Diff`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff) produces human-readable reports of the differences between values.

​	在测试中，您还可以使用 [`"github.com/google/go-cmp/cmp"`](https://pkg.go.dev/github.com/google/go-cmp/cmp?tab=doc) 包及其 [`protocmp.Transform()`](https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp#Transform) 选项。`cmp` 包可以比较任意数据结构，并且 [`cmp.Diff`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff) 生成可读性强的差异报告。

```go
if diff := cmp.Diff(a, b, protocmp.Transform()); diff != "" {
  t.Errorf("unexpected difference:\n%v", diff)
}
```

## Hyrum 法则 Hyrum’s Law

### 什么是 Hyrum 法则？为什么它出现在常见问题解答中？ What is Hyrum’s Law, and why is it in this FAQ?

[Hyrum’s Law](https://www.hyrumslaw.com/) states:

​	[Hyrum 法则](https://www.hyrumslaw.com/) 表示：

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.
>
> ​	对于一个有足够多用户的 API，无论您在契约中承诺了什么，系统的所有可观察行为都会被某些人依赖。

A design goal of the latest version of the Go protocol buffer API is to avoid, where possible, providing observable behaviors that we cannot promise to keep stable in the future. It is our philosophy that deliberate instability in areas where we make no promises is better than giving the illusion of stability, only for that to change in the future after a project has potentially been long depending on that false assumption.

​	Go Protocol Buffers API 最新版本的设计目标是尽量避免提供我们无法在未来保证稳定性的可观察行为。我们的理念是，与其给人稳定性的假象，之后再因项目长期依赖错误假设而更改，不如在不承诺的领域有意保持不稳定。

### 为什么错误文本会不断变化？ Why does the text of errors keep changing?

Tests depending on the exact text of errors are brittle and break often when that text changes. To discourage unsafe use of error text in tests, the text of errors produced by this module is deliberately unstable.

​	依赖错误文本的测试是脆弱的，当错误文本变化时会频繁破坏。因此，为了阻止测试中错误文本的危险使用，本模块生成的错误文本故意保持不稳定。

If you need to identify whether an error is produced by the [`protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf) module, we guarantee that all errors will match [`proto.Error`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Error) according to [`errors.Is`](https://pkg.go.dev/errors?tab=doc#Is).

​	如果需要识别错误是否由 [`protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf) 模块生成，我们保证所有错误会根据 [`errors.Is`](https://pkg.go.dev/errors?tab=doc#Is) 匹配 [`proto.Error`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Error)。

### 为什么 [`protojson`](https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson) 的输出不断变化？ Why does the output of [`protojson`](https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson) keep changing?

We make no promises about the long-term stability of Go’s implementation of the [JSON format for protocol buffers](https://protobuf.dev/programming-guides/proto3#json). The specification only specifies what is valid JSON, but provides no specification for a *canonical* format for how a marshaler ought to *exactly* format a given message. To avoid giving the illusion that the output is stable, we deliberately introduce minor differences so that byte-for-byte comparisons are likely to fail.

​	我们对 Go 对 Protobuf [JSON 格式](https://protobuf.dev/programming-guides/proto3#json) 的实现不做长期稳定性的承诺。规范仅规定了有效 JSON 的要求，但未规定一个 *规范格式*。为避免输出看似稳定的假象，我们故意引入微小差异，使字节对字节的比较可能失败。

To gain some degree of output stability, we recommend running the output through a JSON formatter.

**建议：** 使用 JSON 格式化工具处理输出以获得一定的稳定性。 

### 为什么 [`prototext`](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext) 的输出不断变化？ Why does the output of [`prototext`](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext) keep changing?

We make no promises about the long-term stability of Go’s implementation of the text format. There is no canonical specification of the protobuf text format, and we would like to preserve the ability to make improvements in the `prototext` package output in the future. Since we don’t promise stability in the package’s output, we’ve deliberately introduced instability to discourage users from depending on it.

​	我们对 Go 对 Protobuf 文本格式的实现不做长期稳定性的承诺。由于文本格式没有规范定义，我们希望保留未来改进 `prototext` 包输出的能力。因此，我们有意在输出中引入不稳定性以阻止用户对其依赖。

To obtain some degree of stability, we recommend passing the output of `prototext` through the [`txtpbfmt`](https://github.com/protocolbuffers/txtpbfmt) program. The formatter can be directly invoked in Go using [`parser.Format`](https://pkg.go.dev/github.com/protocolbuffers/txtpbfmt/parser?tab=doc#Format).

​	**建议：** 将 `prototext` 的输出通过 [`txtpbfmt`](https://github.com/protocolbuffers/txtpbfmt) 程序格式化。您可以在 Go 中直接调用 [`parser.Format`](https://pkg.go.dev/github.com/protocolbuffers/txtpbfmt/parser?tab=doc#Format) 格式化器。

## 杂项 Miscellaneous

### 如何将 Protocol Buffer 消息用作哈希键？ How do I use a protocol buffer message as a hash key?

You need canonical serialization, where the marshaled output of a protocol buffer message is guaranteed to be stable over time. Unfortunately, no specification for canonical serialization exists at this time. You’ll need to write your own or find a way to avoid needing one.

​	您需要规范化序列化，这意味着 Protocol Buffer 消息的序列化输出在时间上必须稳定。然而，目前并没有规范化序列化的标准。您需要自行编写规范化逻辑，或者找到一种方法避免依赖此需求。

### 我可以为 Go Protocol Buffer 实现添加新特性吗？ Can I add a new feature to the Go protocol buffer implementation?

Maybe. We always like suggestions, but we’re very cautious about adding new things.

​	**可能可以。** 我们欢迎建议，但对添加新功能持非常谨慎的态度。

The Go implementation of protocol buffers strives to be consistent with the other language implementations. As such, we tend to shy away from feature that are overly specialized to just Go. Go-specific features hinder the goal of protocol buffers being a language-neutral data interchange format.

​	Go 的 Protocol Buffer 实现力求与其他语言的实现保持一致。因此，我们通常避免仅针对 Go 的过度专门化特性。Go 特定功能可能会妨碍 Protocol Buffers 成为语言中立的数据交换格式的目标。

Unless your idea is specific to the Go implementation, you should join the [protobuf discussion group](http://groups.google.com/group/protobuf) and suggest it there.

​	除非您的想法仅适用于 Go 实现，否则您应该加入 [protobuf 讨论组](http://groups.google.com/group/protobuf) 并在那里提出建议。

If you have an idea for the Go implementation, file an issue on our issue tracker: 如果您有针对 Go 实现的想法，请在我们的问题跟踪器上提交问题： https://github.com/golang/protobuf/issues

### 我可以为 `Marshal` 或 `Unmarshal` 添加自定义选项吗？ Can I add an option to `Marshal` or `Unmarshal` to customize it?

Only if that option exists in other implementations (e.g., C++, Java). The encoding of protocol buffers (binary, JSON, and text) must be consistent across implementations, so a program written in one language is able to read messages written by another one.

​	**只有当其他实现（例如 C++、Java）中存在该选项时才可以。** Protocol Buffers 的编码（包括二进制、JSON 和文本）必须在不同实现间保持一致，以确保一种语言编写的程序能够读取另一种语言写入的消息。

We will not add any options to the Go implementation that affect the data output by `Marshal` functions or read by `Unmarshal` functions unless an equivalent option exist in at least one other supported implementation.

​	我们不会为 Go 实现添加任何影响 `Marshal` 函数生成的数据或 `Unmarshal` 函数读取的数据的选项，除非至少有一种其他支持的实现中存在等效选项。

### 我可以自定义 `protoc-gen-go` 生成的代码吗？ Can I customize the code generated by `protoc-gen-go`?

In general, no. Protocol buffers are intended to be a language-agnostic data interchange format, and implementation-specific customizations run counter to that intent.

​	通常来说，不可以。Protocol Buffers 的目标是成为一种语言无关的数据交换格式，特定实现的自定义与此目标相违背。
