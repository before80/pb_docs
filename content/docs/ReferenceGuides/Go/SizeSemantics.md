+++
title = "Size 语义"
date = 2024-11-17T12:07:24+08:00
weight = 20
type = "docs"
description = ""
isCJKLanguage = true
draft = false

+++

> 原文：[https://protobuf.dev/reference/go/size/](https://protobuf.dev/reference/go/size/)
>
> 收录该文档的时间：`2024-11-17T12:07:24+08:00`

# Go Size Semantics - Go Size 语义

Explains how (not) to use proto.Size

​	解释如何（以及如何不）使用 `proto.Size`。

The [`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) function returns the size in bytes of the wire-format encoding of a proto.Message by traversing all its fields (including submessages).

​	[`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) 函数通过遍历所有字段（包括子消息）返回 `proto.Message` 的线格式编码的字节大小。

In particular, it returns the size of **how Go Protobuf will encode the message**.

​	特别地，它返回**Go Protobuf 编码消息的大小**。

## 常见用法 Typical usages

### 判断消息是否为空 Identifying empty messages

Checking if [`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) returns 0 is an easy way to recognize empty messages:

​	检查 [`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) 是否返回 0 是识别空消息的一种简单方法：

```go
if proto.Size(m) == 0 {
    // No fields set (or, in proto3, all fields matching the default);
    // skip processing this message, or return an error, or similar.
    // 没有设置任何字段（或在 proto3 中，所有字段都匹配默认值）；
    // 跳过处理该消息，或者返回错误，或其他处理。
}
```

### 限制程序输出大小 Size-limiting program output

Let’s say you’re writing a batch processing pipeline which produces work tasks for another system that we’ll call “downstream system” in this example. The downstream system is provisioned for handling small to medium-sized tasks, but load testing has shown that the system runs into a cascading failure when presented with a work task of over 500 MB.

​	假设您正在编写一个批处理管道，用于为另一个系统生成任务，该系统在此示例中称为“下游系统”。下游系统被设计为处理小到中等大小的任务，但负载测试显示，当任务超过 500 MB 时，该系统可能会发生级联故障。

The best fix is to add protection to the downstream system (see https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons), but when implementing load-shedding is infeasible, you could decide to add a quick fix to your pipeline:

​	最佳解决方案是为下游系统添加保护措施（请参阅 [负载削减](https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons)），但如果无法实现负载削减，可以在管道中添加一个快速修复：

```go
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) {
  task := produceWorkTask(value)
  if proto.Size(task) > 100 * 1024 * 1024 {
    // Skip every work task over 100 MB to not overwhelm
    // the brittle downstream system.
    // 跳过超过 100 MB 的任务以免压垮脆弱的下游系统。
    return
  }
  emit(task)
}
```

## 错误用法：与 Unmarshal 无关 Incorrect usage: no relation to Unmarshal

Because [`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) returns the number of bytes for how Go Protobuf will encode the message, it is not safe to use `proto.Size` when unmarshaling (decoding) a stream of incoming Protobuf messages:

​	由于 [`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) 返回的是 Go Protobuf 如何编码消息的字节数，因此在反序列化（解码）传入的 Protobuf 消息流时使用 `proto.Size` 是不安全的：

```go
func bytesToSubscriptionList(data []byte) ([]*vpb.EventSubscription, error) {
    subList := []*vpb.EventSubscription{}
    for len(data) > 0 {
        subscription := &vpb.EventSubscription{}
        if err := proto.Unmarshal(data, subscription); err != nil {
            return nil, err
        }
        subList = append(subList, subscription)
        data = data[:len(data)-proto.Size(subscription)]
    }
    return subList, nil
}
```

When `data` contains a message in [non-minimal wire format](https://protobuf.dev/reference/go/size/#non-minimal), `proto.Size` can return a different size than was actually unmarshaled, resulting in a parsing error (best case) or incorrectly parsed data in the worst case.

​	当 `data` 包含[非最小化线格式](https://protobuf.dev/reference/go/size/#non-minimal)的消息时，`proto.Size` 返回的大小可能与实际反序列化的大小不同，导致解析错误（最好情况）或错误地解析数据（最坏情况）。

Hence, this example only works reliably as long as all input messages are generated by (the same version of) Go Protobuf. This is surprising and likely not intended.

​	因此，该示例仅在所有输入消息由（相同版本的）Go Protobuf 生成时可靠。这种行为令人意外，可能不是预期的。

**Tip:** Use the [`protodelim` package](https://pkg.go.dev/google.golang.org/protobuf/encoding/protodelim) instead to read/write size-delimited streams of Protobuf messages.

​	**提示：** 使用 [`protodelim` 包](https://pkg.go.dev/google.golang.org/protobuf/encoding/protodelim) 读取/写入大小分隔的 Protobuf 消息流。

## 高级用法：预分配缓冲区 Advanced usage: pre-sizing buffers

An advanced usage of [`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) is to determine the required size for a buffer before marshaling:

​	[`proto.Size`]({{< ref "/docs/ReferenceGuides/Go/GoAPI#Size" >}}) 的高级用法是确定序列化前缓冲区的所需大小：

```go
opts := proto.MarshalOptions{
    // Possibly avoid an extra proto.Size in Marshal itself (see docs):
    // 可能避免 Marshal 自身中的额外 proto.Size 调用（见文档）：
    UseCachedSize: true,
}
// DO NOT SUBMIT without implementing this Optimization opportunity:
// instead of allocating, grab a sufficiently-sized buffer from a pool.
// Knowing the size of the buffer means we can discard
// outliers from the pool to prevent uncontrolled
// memory growth in long-running RPC services.
// 不要提交以下代码，需先实现优化：
// 不要分配新的内存，而是从池中获取足够大的缓冲区。
// 知道缓冲区大小后，可以丢弃池中的异常值，防止长期运行的 RPC 服务中内存无限增长。
buf := make([]byte, 0, opts.Size(m))
var err error
buf, err = opts.MarshalAppend(buf, m) // does not allocate 不会分配新内存
// Note that len(buf) might be less than cap(buf)! Read below:
// 注意，len(buf) 可能小于 cap(buf)！请继续阅读：
```

Note that when lazy decoding is enabled, `proto.Size` might return more bytes than `proto.Marshal` (and variants like `proto.MarshalAppend`) will write! So when you are placing encoded bytes on the wire (or on disk), be sure to work with `len(buf)` and discard any previous `proto.Size` results.

​	注意，当启用了惰性解码时，`proto.Size` 返回的字节数可能比 `proto.Marshal`（以及类似的 `proto.MarshalAppend`）实际写入的字节数更多！因此，当将编码的字节写入线（或磁盘）时，请确保使用 `len(buf)`，而非之前的 `proto.Size` 结果。

Specifically, a (sub-)message can “shrink” between `proto.Size` and `proto.Marshal` when:

​	具体来说，当以下条件满足时，子消息在 `proto.Size` 和 `proto.Marshal` 之间可能会“缩小”：

1. Lazy decoding is enabled 启用了惰性解码；
2. and the message arrived in [non-minimal wire format](https://protobuf.dev/reference/go/size/#non-minimal)  消息以[非最小化线格式](https://protobuf.dev/reference/go/size/#non-minimal)到达；
3. and the message is not accessed before `proto.Size` is called, meaning it is not decoded yet 在调用 `proto.Size` 之前未访问消息，即尚未解码；
4. and the message is accessed after `proto.Size` (but before `proto.Marshal`), causing it to be lazily decoded 在调用 `proto.Size` 之后但调用 `proto.Marshal` 之前访问了消息，导致消息被惰性解码。

The decoding results in any subsequent `proto.Marshal` calls encoding the message (as opposed to merely copying its wire format), which results in implicit normalization to how Go encodes messages, which is currently in minimal wire format (but don’t rely on that!).

​	解码后，后续的 `proto.Marshal` 调用会重新编码消息（而非仅复制其线格式），从而隐式地将消息规范化为 Go 的编码方式（目前为最小化线格式，但不要依赖此行为！）。

As you can see, the scenario is rather specific, but nevertheless it is **best practice to treat `proto.Size` results as an upper bound** and never assume that the result matches the actually encoded message size.

​	因此，**最佳实践是将 `proto.Size` 的结果视为上限**，不要假设其结果与实际编码的消息大小匹配。

## 背景：非最小化线格式 Background: Non-minimal wire format

When encoding Protobuf messages, there is one *minimal wire format size* and a number of larger *non-minimal wire formats* that decode to the same message.

​	在对 Protobuf 消息进行编码时，存在一种*最小化线格式大小*以及若干更大的*非最小化线格式*，它们解码后等价于同一消息。

Non-minimal wire format (also called “denormalized wire format” sometimes) refers to scenarios like non-repeated fields appearing multiple times, non-optimal varint encoding, packed repeated fields that appear non-packed on the wire and others.

​	非最小化线格式（有时也称为“非规范化线格式”）是指以下场景，例如非重复字段多次出现、非最优的 varint 编码、在线格式中显示为非打包的打包重复字段等情况。

We can encounter non-minimal wire format in different scenarios:

​	在不同场景下，我们可能会遇到非最小化线格式：

- **Intentionally.** Protobuf supports concatenating messages by concatenating their wire format.
  - **有意生成。** Protobuf 支持通过拼接其线格式来拼接消息。

- **Accidentally.** A (possibly third-party) Protobuf encoder does not encode ideally (e.g. uses more space than necessary when encoding a varint).
  - **意外生成。** 某些（可能是第三方的）Protobuf 编码器未进行最佳编码（例如在编码 varint 时占用了比必要更多的空间）。
- **Maliciously.** An attacker could craft Protobuf messages specifically to trigger crashes over the network.
  - **恶意生成。** 攻击者可以专门制作 Protobuf 消息，以通过网络触发崩溃。
