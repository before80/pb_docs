+++
title = "Go FAQ"
weight = 620
linkTitle = "FAQ"
description = "关于在 Go 中实现协议缓冲区的一系列常见问题，并附有每个问题的答案。"
type = "docs"
+++

> 原文网址： 

## Go FAQ Go 常见问题解答

A list of frequently asked questions about implementing protocol buffers in Go, with answer for each.

​	关于在 Go 中实现协议缓冲区的一系列常见问题，并附有每个问题的答案。



## Versions 版本

### What’s the difference between `github.com/golang/protobuf` and `google.golang.org/protobuf`? `github.com/golang/protobuf` 和 `google.golang.org/protobuf` 有什么区别？

The [`github.com/golang/protobuf`](https://pkg.go.dev/github.com/golang/protobuf?tab=overview) module is the original Go protocol buffer API.
`github.com/golang/protobuf` 模块是最初的 Go 协议缓冲区 API。

The [`google.golang.org/protobuf`](https://pkg.go.dev/google.golang.org/protobuf?tab=overview) module is an updated version of this API designed for simplicity, ease of use, and safety. The flagship features of the updated API are support for reflection and a separation of the user-facing API from the underlying implementation.
`google.golang.org/protobuf` 模块是此 API 的更新版本，旨在实现简单、易用和安全。更新的 API 的主要功能是对反射的支持以及用户界面 API 与底层实现的分离。

We recommend that you use `google.golang.org/protobuf` in new code.
我们建议您在新代码中使用 `google.golang.org/protobuf` 。

Version `v1.4.0` and higher of `github.com/golang/protobuf` wrap the new implementation and permit programs to adopt the new API incrementally. For example, the well-known types defined in `github.com/golang/protobuf/ptypes` are simply aliases of those defined in the newer module. Thus, [`google.golang.org/protobuf/types/known/emptypb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/emptypb) and [`github.com/golang/protobuf/ptypes/empty`](https://pkg.go.dev/github.com/golang/protobuf/ptypes/empty) may be used interchangeably.
`github.com/golang/protobuf` 的 `v1.4.0` 及更高版本包装了新实现，并允许程序逐步采用新 API。例如，在 `github.com/golang/protobuf/ptypes` 中定义的众所周知的类型只是在较新的模块中定义的类型的别名。因此， `google.golang.org/protobuf/types/known/emptypb` 和 `github.com/golang/protobuf/ptypes/empty` 可以互换使用。

### What are `proto1`, `proto2`, and `proto3`? `proto1` 、 `proto2` 和 `proto3` 是什么？

These are revisions of the protocol buffer *language*. It is different from the Go *implementation* of protobufs.
这些是协议缓冲区语言的修订版本。它不同于 protobufs 的 Go 实现。

- `proto3` is the current version of the language. This is the most commonly used version of the language. We encourage new code to use proto3.
  `proto3` 是该语言的当前版本。这是该语言最常用的版本。我们鼓励新代码使用 proto3。
- `proto2` is an older version of the language. Despite being superseded by proto3, proto2 is still fully supported.
  `proto2` 是该语言的较旧版本。尽管已被 proto3 取代，但 proto2 仍得到全面支持。
- `proto1` is an obsolete version of the language. It was never released as open source.
  `proto1` 是该语言的过时版本。它从未作为开源版本发布。

### There are several different `Message` types. Which should I use? 有几种不同的 `Message` 类型。我应该使用哪种？

- [`"google.golang.org/protobuf/proto".Message`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Message) is an interface type implemented by all messages generated by the current version of the protocol buffer compiler. Functions that operate on arbitrary messages, such as [`proto.Marshal`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal) or [`proto.Clone`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Clone), accept or return this type.
  `"google.golang.org/protobuf/proto".Message` 是由协议缓冲区编译器的当前版本生成的所有消息实现的接口类型。对任意消息进行操作的函数（例如 `proto.Marshal` 或 `proto.Clone` ）接受或返回此类型。

- [`"google.golang.org/protobuf/reflect/protoreflect".Message`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message) is an interface type describing a reflection view of a message.
  `"google.golang.org/protobuf/reflect/protoreflect".Message` 是描述消息的反射视图的接口类型。

  Call the `ProtoReflect` method on a `proto.Message` to get a `protoreflect.Message`.
  调用 `ProtoReflect` 方法获取 `proto.Message` 的 `protoreflect.Message` 。

- [`"google.golang.org/protobuf/reflect/protoreflect".ProtoMessage`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#ProtoMessage) is an alias of `"google.golang.org/protobuf/proto".Message`. The two types are interchangeable.
  `"google.golang.org/protobuf/reflect/protoreflect".ProtoMessage` 是 `"google.golang.org/protobuf/proto".Message` 的别名。这两种类型可以互换。

- [`"github.com/golang/protobuf/proto".Message`](https://pkg.go.dev/github.com/golang/protobuf/proto?tab=doc#Message) is an interface type defined by the legacy Go protocol buffer API. All generated message types implement this interface, but the interface does not describe the behavior expected from these messages. New code should avoid using this type.
  `"github.com/golang/protobuf/proto".Message` 是由旧版 Go 协议缓冲区 API 定义的接口类型。所有生成的 message 类型都实现了此接口，但该接口并未描述这些 message 预期的行为。新代码应避免使用此类型。

## Common problems 常见问题

### “`go install`”: `working directory is not part of a module`

On Go 1.15 and below, you have set the environment variable `GO111MODULE=on` and are running the `go install` command outside of a module directory. Set `GO111MODULE=auto`, or unset the environment variable.
在 Go 1.15 及更低版本中，您已设置环境变量 `GO111MODULE=on` ，并且在模块目录之外运行 `go install` 命令。设置 `GO111MODULE=auto` ，或取消设置环境变量。

On Go 1.16 and above, `go install` can be invoked outside of a module by specifying an explicit version: `go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`
在 Go 1.16 及更高版本中，可以通过指定显式版本在模块外部调用 `go install` ： `go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`

### `constant -1 overflows protoimpl.EnforceVersion`

You are using a generated `.pb.go` file which requires a newer version of the `"google.golang.org/protobuf"` module.
您正在使用生成的 `.pb.go` 文件，该文件需要更新版本的 `"google.golang.org/protobuf"` 模块。

Update to a newer version with:
使用以下命令更新到较新版本：

```shell
go get -u google.golang.org/protobuf/proto
```

### `undefined: "github.com/golang/protobuf/proto".ProtoPackageIsVersion4`

You are using a generated `.pb.go` file which requires a newer version of the `"github.com/golang/protobuf"` module.
您正在使用生成的 `.pb.go` 文件，该文件需要更新版本的 `"github.com/golang/protobuf"` 模块。

Update to a newer version with:
使用以下命令更新到较新版本：

```shell
go get -u github.com/golang/protobuf/proto
```

### What is a protocol buffer namespace conflict? 什么是协议缓冲区命名空间冲突？

All protocol buffers declarations linked into a Go binary are inserted into a global registry.
链接到 Go 二进制文件的所有协议缓冲区声明都插入到全局注册表中。

Every protobuf declaration (for example, enums, enum values, or messages) has an absolute name, which is the concatenation of the [package name](https://protobuf.dev/programming-guides/proto2#packages) with the relative name of the declaration in the `.proto` source file (for example, `my.proto.package.MyMessage.NestedMessage`). The protobuf language assumes that all declarations are universally unique.
每个 protobuf 声明（例如，枚举、枚举值或消息）都有一个绝对名称，它是包名称与声明在 `.proto` 源文件中的相对名称的连接（例如， `my.proto.package.MyMessage.NestedMessage` ）。protobuf 语言假定所有声明都是全局唯一的。

If two protobuf declarations linked into a Go binary have the same name, then this leads to a namespace conflict, and it is impossible for the registry to properly resolve that declaration by name. Depending on which version of Go protobufs is being used, this will either panic at init-time or silently drop the conflict and lead to a potential bug later during runtime.
如果链接到 Go 二进制文件的两个 protobuf 声明具有相同的名称，则会导致命名空间冲突，并且注册表无法按名称正确解析该声明。根据所用 Go protobuf 的版本，这将在初始化时引发错误，或静默地删除冲突，并可能在运行时导致潜在的错误。

### How do I fix a protocol buffer namespace conflict? 如何修复协议缓冲区命名空间冲突？

The way to best fix a namespace conflict depends on the reason why a conflict is occurring.
最佳修复命名空间冲突的方法取决于冲突发生的原因。

Common ways that namespace conflicts occur:
命名空间冲突发生的常见方式：

- **Vendored .proto files.** When a single `.proto` file is generated into two or more Go packages and linked into the same Go binary, it conflicts on every protobuf declaration in the generated Go packages. This typically occurs when a `.proto` file is vendored and a Go package is generated from it, or the generated Go package itself is vendored. Users should avoid vendoring and instead depend on a centralized Go package for that `.proto` file.
  供应商 .proto 文件。当一个 `.proto` 文件生成到两个或更多个 Go 包中并链接到同一个 Go 二进制文件时，它会与生成的 Go 包中的每个 protobuf 声明发生冲突。这通常发生在 `.proto` 文件被供应商化并且从中生成了一个 Go 包，或者生成的 Go 包本身被供应商化时。用户应避免供应商化，而应依赖于该 `.proto` 文件的集中式 Go 包。
  - If a `.proto` file is owned by an external party and is lacking a `go_package` option, then you should coordinate with the owner of that `.proto` file to specify a centralized Go package that a plurality of users can all depend on.
    如果 `.proto` 文件归外部方所有并且缺少 `go_package` 选项，那么您应与该 `.proto` 文件的所有者协调，以指定多个用户都可以依赖的集中式 Go 包。
- **Missing or generic proto package names.** If a `.proto` file does not specify a package name or uses an overly generic package name (for example, “my_service”), then there is a high probability that declarations within that file will conflict with other declarations elsewhere in the universe. We recommend that every `.proto` file have a package name that is deliberately chosen to be universally unique (for example, prefixed with the name of a company).
  缺少或通用的 proto 包名称。如果 `.proto` 文件未指定包名称或使用过于通用的包名称（例如，“my_service”），则该文件中的声明很可能会与宇宙其他地方的其他声明冲突。我们建议每个 `.proto` 文件都具有一个经过深思熟虑的、在全球范围内唯一的包名称（例如，以公司名称为前缀）。
  - **Warning:** Retroactively changing the package name on a `.proto` file is not backwards compatible for types used as extension fields, stored in `google.protobuf.Any`, or for gRPC Service definitions.
    警告：追溯更改 `.proto` 文件上的包名称与用作扩展字段、存储在 `google.protobuf.Any` 中的类型或 gRPC 服务定义向后不兼容。

Starting with v1.26.0 of the `google.golang.org/protobuf` module, a hard error will be reported when a Go program starts up that has multiple conflicting protobuf names linked into it. While it is preferable that the source of the conflict be fixed, the fatal error can be immediately worked around in one of two ways:
从 `google.golang.org/protobuf` 模块的 v1.26.0 开始，当启动链接了多个冲突 protobuf 名称的 Go 程序时，将报告一个硬错误。虽然最好修复冲突的根源，但可以通过以下两种方式之一立即解决致命错误：

1. **At compile time.** The default behavior for handling conflicts can be specified at compile time with a linker-initialized variable: `go build -ldflags "-X google.golang.org/protobuf/reflect/protoregistry.conflictPolicy=warn"`
   在编译时。可以在编译时使用链接器初始化变量指定处理冲突的默认行为： `go build -ldflags "-X google.golang.org/protobuf/reflect/protoregistry.conflictPolicy=warn"`
2. **At program execution.** The behavior for handling conflicts when executing a particular Go binary can be set with an environment variable: `GOLANG_PROTOBUF_REGISTRATION_CONFLICT=warn ./main`
   在程序执行时。执行特定 Go 二进制文件时处理冲突的行为可以通过环境变量设置： `GOLANG_PROTOBUF_REGISTRATION_CONFLICT=warn ./main`

### Why does `reflect.DeepEqual` behave unexpectedly with protobuf messages? 为什么 `reflect.DeepEqual` 对 protobuf 消息的行为出乎意料？

Generated protocol buffer message types include internal state which can vary even between equivalent messages.
生成的协议缓冲区消息类型包括内部状态，即使在等效消息之间也会有所不同。

In addition, the `reflect.DeepEqual` function is not aware of the semantics of protocol buffer messages, and can report differences where none exist. For example, a map field containing a `nil` map and one containing a zero-length, non-`nil` map are semantically equivalent, but will be reported as unequal by `reflect.DeepEqual`.
此外， `reflect.DeepEqual` 函数不了解协议缓冲区消息的语义，并且可能会报告不存在的差异。例如，包含 `nil` 映射的映射字段和包含零长度、非 `nil` 映射的映射字段在语义上是等效的，但 `reflect.DeepEqual` 会将它们报告为不相等。

Use the [`proto.Equal`](https://pkg.go.dev/google.golang.org/protobuf/proto#Equal) function to compare message values.
使用 `proto.Equal` 函数比较消息值。

In tests, you can also use the [`"github.com/google/go-cmp/cmp"`](https://pkg.go.dev/github.com/google/go-cmp/cmp?tab=doc) package with the [`protocmp.Transform()`](https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp#Transform) option. The `cmp` package can compare arbitrary data structures, and [`cmp.Diff`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff) produces human-readable reports of the differences between values.
在测试中，您还可以将 `"github.com/google/go-cmp/cmp"` 包与 `protocmp.Transform()` 选项一起使用。 `cmp` 包可以比较任意数据结构， `cmp.Diff` 会生成可读的差异值报告。

```go
if diff := cmp.Diff(a, b, protocmp.Transform()); diff != "" {
  t.Errorf("unexpected difference:\n%v", diff)
}
```

## Hyrum’s Law 海伦姆定律

### What is Hyrum’s Law, and why is it in this FAQ? 海伦姆定律是什么，为什么它会出现在此常见问题解答中？

[Hyrum’s Law](https://www.hyrumslaw.com/) states:
海伦姆定律指出：

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.
> 如果 API 的用户足够多，那么无论您在合同中承诺什么：您的系统的全部可观察行为都将由某人依赖。

A design goal of the latest version of the Go protocol buffer API is to avoid, where possible, providing observable behaviors that we cannot promise to keep stable in the future. It is our philosophy that deliberate instability in areas where we make no promises is better than giving the illusion of stability, only for that to change in the future after a project has potentially been long depending on that false assumption.
Go 协议缓冲区 API 最新版本的其中一个设计目标是尽可能避免提供我们无法保证在未来保持稳定的可观察行为。我们的理念是，在没有做出任何承诺的领域中故意保持不稳定性，要优于提供稳定性的假象，因为在项目长期依赖于这种错误假设后，这种假象可能会在未来发生改变。

### Why does the text of errors keep changing? 错误的文本为何不断变化？

Tests depending on the exact text of errors are brittle and break often when that text changes. To discourage unsafe use of error text in tests, the text of errors produced by this module is deliberately unstable.
依赖于错误的准确文本的测试很脆弱，并且在文本发生变化时经常会中断。为了阻止在测试中不安全地使用错误文本，此模块生成的错误文本故意保持不稳定。

If you need to identify whether an error is produced by the [`protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf) module, we guarantee that all errors will match [`proto.Error`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Error) according to [`errors.Is`](https://pkg.go.dev/errors?tab=doc#Is).
如果您需要识别错误是否由 `protobuf` 模块生成，我们保证所有错误都将根据 `errors.Is` 与 `proto.Error` 匹配。

### Why does the output of [`protojson`](https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson) keep changing? `protojson` 的输出为何不断变化？

We make no promises about the long-term stability of Go’s implementation of the [JSON format for protocol buffers](https://protobuf.dev/programming-guides/proto3#json). The specification only specifies what is valid JSON, but provides no specification for a *canonical* format for how a marshaler ought to *exactly* format a given message. To avoid giving the illusion that the output is stable, we deliberately introduce minor differences so that byte-for-byte comparisons are likely to fail.
我们不对 Go 实现的协议缓冲区的 JSON 格式的长期稳定性做出任何承诺。该规范仅指定有效的 JSON 是什么，但没有提供关于编组器应该如何准确地格式化给定消息的规范格式的规范。为了避免给人输出稳定的错觉，我们故意引入细微的差异，以便逐字节比较可能会失败。

To gain some degree of output stability, we recommend running the output through a JSON formatter.
为了获得一定程度的输出稳定性，我们建议通过 JSON 格式化程序运行输出。

### Why does the output of [`prototext`](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext) keep changing? 为什么 `prototext` 的输出不断变化？

We make no promises about the long-term stability of Go’s implementation of the text format. There is no canonical specification of the protobuf text format, and we would like to preserve the ability to make improvements in the `prototext` package output in the future. Since we don’t promise stability in the package’s output, we’ve deliberately introduced instability to discourage users from depending on it.
我们不对 Go 实现的文本格式的长期稳定性做出任何承诺。没有 protobuf 文本格式的规范规范，我们希望保留在未来改进 `prototext` 包输出的能力。由于我们不保证包的输出稳定，因此我们故意引入不稳定性以阻止用户依赖它。

To obtain some degree of stability, we recommend passing the output of `prototext` through the [`txtpbfmt`](https://github.com/protocolbuffers/txtpbfmt) program. The formatter can be directly invoked in Go using [`parser.Format`](https://pkg.go.dev/github.com/protocolbuffers/txtpbfmt/parser?tab=doc#Format).
为了获得一定程度的稳定性，我们建议将 `prototext` 的输出通过 `txtpbfmt` 程序传递。可以使用 `parser.Format` 在 Go 中直接调用格式化程序。

## Miscellaneous 其他

### How do I use a protocol buffer message as a hash key? 如何将协议缓冲区消息用作哈希键？

You need canonical serialization, where the marshaled output of a protocol buffer message is guaranteed to be stable over time. Unfortunately, no specification for canonical serialization exists at this time. You’ll need to write your own or find a way to avoid needing one.
您需要规范序列化，其中协议缓冲区消息的编组输出保证随着时间的推移而保持稳定。不幸的是，目前尚不存在规范序列化的规范。您需要编写自己的规范或找到一种方法来避免需要规范。

### Can I add a new feature to the Go protocol buffer implementation? 我可以向 Go 协议缓冲区实现添加新功能吗？

Maybe. We always like suggestions, but we’re very cautious about adding new things.
也许可以。我们始终欢迎建议，但我们对添加新功能非常谨慎。

The Go implementation of protocol buffers strives to be consistent with the other language implementations. As such, we tend to shy away from feature that are overly specialized to just Go. Go-specific features hinder the goal of protocol buffers being a language-neutral data interchange format.
Go 协议缓冲区的实现力求与其他语言实现保持一致。因此，我们倾向于避开仅对 Go 过度专门化的功能。特定于 Go 的功能会阻碍协议缓冲区成为语言中立的数据交换格式的目标。

Unless your idea is specific to the Go implementation, you should join the [protobuf discussion group](http://groups.google.com/group/protobuf) and suggest it there.
除非您的想法特定于 Go 实现，否则您应该加入 protobuf 讨论组并在那里提出建议。

If you have an idea for the Go implementation, file an issue on our issue tracker: https://github.com/golang/protobuf/issues
如果您对 Go 实现有任何想法，请在我们的问题跟踪器上提交问题：https://github.com/golang/protobuf/issues

### Can I add an option to `Marshal` or `Unmarshal` to customize it? 我可以添加一个选项来 `Marshal` 或 `Unmarshal` 以自定义它吗？

Only if that option exists in other implementations (e.g., C++, Java). The encoding of protocol buffers (binary, JSON, and text) must be consistent across implementations, so a program written in one language is able to read messages written by another one.
仅当其他实现（例如 C++、Java）中存在该选项时。协议缓冲区（二进制、JSON 和文本）的编码必须在各个实现中保持一致，因此用一种语言编写的程序能够读取由另一种语言编写的消息。

We will not add any options to the Go implementation that affect the data output by `Marshal` functions or read by `Unmarshal` functions unless an equivalent option exist in at least one other supported implementation.
除非至少在一个其他受支持的实现中存在等效选项，否则我们不会向 Go 实现添加任何影响 `Marshal` 函数的数据输出或 `Unmarshal` 函数读取的选项。

### Can I customize the code generated by `protoc-gen-go`? 我可以自定义 `protoc-gen-go` 生成的代码吗？

In general, no. Protocol buffers are intended to be a language-agnostic data interchange format, and implementation-specific customizations run counter to that intent.
通常情况下，不行。协议缓冲区旨在成为一种与语言无关的数据交换格式，而特定于实现的自定义与该意图背道而驰。
